const int MAX_STEPS = 500;
const float MAX_DIST = 100000.0;
const float MIN_DIST = 0.01;

const float3 gDefaultCol = float3(0.0,0.0,0.0);
const float gShadowSoftness = 15.0;

struct Object
{
    // Rotation matrix
    float3x3 Rotation(const in float3 rotation) 
    {
        float cx = cos(rotation.x);
        float sx = sin(rotation.x);
        float cy = cos(rotation.y);
        float sy = sin(rotation.y);
        float cz = cos(rotation.z);
        float sz = sin(rotation.z);
        return mul(
            float3x3(
                float3(cz, -sz, 0),
                float3(sz, cz, 0),
                float3(0, 0, 1)),
            mul(
            float3x3(
                float3(cy, 0, -sy),
                float3(0, 1, 0),
                float3(sy, 0, cy)),
            float3x3(
                float3(1, 0, 0),
                float3(0, cx, sx),
                float3(0, -sx, cx))));
    }

    float GetDist(const in float3 pos, const in float cubeRad, const in float3x3 rot)
    {
        float3 potition = mul(pos, rot);
        return min(MAX_DIST, length(max(abs(potition) - cubeRad, 0.0)));
    }
    float3 GetNormal(const in float3 newPos, const in float3 cubeOrig, const in float cubeRad, const in float3x3 rot)
    {
        float3 pos = newPos;// - cubeOrig;

        float dist = GetDist(pos, cubeRad, rot);
        float2 add = float2(0.01,0.0);
        
        float3 normal = 
            float3(
            GetDist(pos+add.xyy, cubeRad, rot),
            GetDist(pos+add.yxy, cubeRad, rot),
            GetDist(pos+add.yyx, cubeRad, rot))
                -
            float3(
            GetDist(pos-add.xyy, cubeRad, rot),
            GetDist(pos-add.yxy, cubeRad, rot),
            GetDist(pos-add.yyx, cubeRad, rot));
        return normalize(normal);
    }
};

struct MarchInfo
{
    float3 lastPos;
    float dist;
    float lastDist;
    int steps;
};

struct Marcher
{
    float CalcSoftShadow(const in float3 rayOrigin, const in float3 rayDirection, const in float3 cubeOrig, const in float cubeRad, const float3 cubeRotation)
    {
        float rayLength = 0.0;
        const float maxShadowRenderDist = 20.0;

        Object obj;
        float3x3 rotMatrix = obj.Rotation(cubeRotation);

        float shadow = 1.0;
        for(int steps = 0; steps < MAX_STEPS; steps++)
        {
            if(rayLength > maxShadowRenderDist)
            {
                break;
            }

            float newDist = obj.GetDist(rayOrigin + rayLength * rayDirection - cubeOrig, cubeRad, rotMatrix);
            if(newDist <= MIN_DIST)
            {
                return 0.0;
            }

            rayLength += newDist;
            shadow = min(shadow, gShadowSoftness * newDist / rayLength);
        }

        return clamp(shadow,0.0,1.0);
    }
    float GetLighting(const in MarchInfo march, const in float3 lightOrigin, const in float3 lightDir, const in float3 cubeOrig, 
        const in float cubeRad, const in float3 normal, const in float3 cubeRotation)
    {   
        //Check dist  
        if(MIN_DIST >= march.lastDist)
        {
            return CalcSoftShadow(march.lastPos + normal * MIN_DIST * 25., lightDir, cubeOrig, cubeRad, cubeRotation);
        }
        return 1.0;
    }
};

//Lighting
Marcher marcher;
MarchInfo march;
march.lastPos = lastPos;
march.dist = distance;
march.lastDist = lastDist;
march.steps = steps;

return marcher.GetLighting(march, lightOrigin, lightDir, cubeOrig, cubeRad, normal, cubeRotation);
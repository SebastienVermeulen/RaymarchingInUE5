const int MAX_STEPS = 500;
const float MAX_DIST = 100000.0;
const float MIN_DIST = 0.01;

const float3 gDefaultCol = float3(0.0,0.0,0.0);
const float gShadowSoftness = 15.0;

struct Object
{
    // Rotation matrix
    float3x3 Rotation(const in float3 rotation) 
    {
        float cx = cos(rotation.x);
        float sx = sin(rotation.x);
        float cy = cos(rotation.y);
        float sy = sin(rotation.y);
        float cz = cos(rotation.z);
        float sz = sin(rotation.z);
        return mul(
            float3x3(
                float3(cz, -sz, 0),
                float3(sz, cz, 0),
                float3(0, 0, 1)),
            mul(
            float3x3(
                float3(cy, 0, -sy),
                float3(0, 1, 0),
                float3(sy, 0, cy)),
            float3x3(
                float3(1, 0, 0),
                float3(0, cx, sx),
                float3(0, -sx, cx))));
    }

    float GetDist(const in float3 newPos, const in float3 cubeOrig, const in float cubeRad, const in float3x3 rot)
    {
        float3 potition = mul((newPos - cubeOrig), rot);
        return min(MAX_DIST, length(max(abs(potition) - cubeRad, 0.0)));
    }
};

struct MarchInfo
{
    float3 lastPos;
    float dist;
    float lastDist;
    int steps;
};

struct Marcher
{
    float CalcSoftShadow(const in float3 rayOrigin, const in float3 lightPos, const in float3 rayDirection, const in float3 cubeOrig, const in float cubeRad, const float3 cubeRotation)
    {
        Object obj;
        float3x3 rotMatrix = obj.Rotation(cubeRotation);

        MarchInfo march;

        float lightDistance;
        float shadow = 1.0;
        for(int steps = 0; steps < MAX_STEPS; steps++)
        {
            march.lastPos = rayOrigin + march.dist * rayDirection;
            
            lightDistance = length(lightPos - march.lastPos);
            march.lastDist = min(obj.GetDist(march.lastPos, cubeOrig, cubeRad, rotMatrix), lightDistance);

            if(MIN_DIST > abs(march.lastDist)) 
            {
                if(MIN_DIST > abs(lightDistance))
                {
                    break;
                }
                shadow = 0.0;
                break;
            }
            if(MAX_DIST < march.dist)
            {
                break;
            }

            march.dist += march.lastDist;
            shadow = min(shadow, gShadowSoftness * march.lastDist / march.dist);
        }

        return clamp(shadow, 0.0, 1.0);
    }
};

//Lighting
Marcher marcher;
return marcher.CalcSoftShadow(lastPos + normal * 2.0, lightOrigin, lightDir, cubeOrig, cubeRad, cubeRotation);